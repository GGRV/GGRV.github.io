---
layout: page
title: Using IntP with stress-ng application
permalink: /Experiments/
---

**Stress−ng** is a tool that loads and causes stress into a computer system or within an application. You can use it by downloading and installing into your system with the following command:

```shell
apt-get install stress-ng
```
To test most of the data outputs given by IntP, the follows command lines were used:

* stress-ng --cpu N
    * start N workers that are continuously writing, reading and removing temporary files.
* stress-ng --hdd N
    * start N workers that are continuously writing, reading and removing temporary files. The default mode is to stress test sequential writes and reads. 
* stress-ng --malloc N
    * start N workers that are continuously calling malloc function.
* stress-ng --cache N
    * start N workers that are performing random-wide spread memory read and write functions to stress the CPU cache. 

## Tests and Outputs

The tests below were executed in a blade server PowerEdge M630 with 24 cores and 32 GB of memory. To perform our tests, we used 3 shell terminals in parallel. This is necessary because a terminal executes the IntP, collecting information about the chosen application. The second presents the results. The third runs the application to be monitored. 


First with IntP command:

```shell
stap --suppress-handler-errors -g intp.stp stress-ng
```
 
 The second with output command:

```shell
watch -n2 -d cat /proc/systemtap/stap_*/intestbench
```
 
 The last terminal was used to run the application (stress-ng):

```shell
stress−ng [OPTION [ARG]] ...
```
 
## Results provided by our tool: 

**$ stress-ng --cpu 12**
```shell
netp    nets    blk     mbw     llcmr   llcocc  cpu
0.00    0.00    0.00    0.00    0.00    0.83    0.50
```
When these parameters were captured in given application point, the application was using 50% of all cpu (**cpu**) resources and 83% of last layer cache (**llcocc**) the hardware had. 

**$ stress-ng --hdd 5**

```shell
netp    nets    blk     mbw     llcmr   llcocc  cpu
0.00    0.00    0.31    0.00    0.00    0.56    0.00
```
Here, the application was using 31% of all disk (**blk**) resources and 56% of last layer cache (**llcocc**) the hardware had.

**$ stress-ng --malloc 1**

```shell
netp    nets    blk     mbw     llcmr   llcocc  cpu
0.00    0.00    0.00    0.10    0.08    0.51    0.07
```
The **llcmr** metric shows a ratio of cycles with outstanding LLC misses to all cycles, in this example is 8%. Also, we had a percentage of memory bus interference usage of 10% (**mbw**).

**$ stress-ng --cache 1**

```shell
netp    nets    blk     mbw     llcmr   llcocc  cpu
0.00    0.00    0.00    0.00    0.05    0.89    0.07
```

These metrics represent the interference caused by the monitored application (in this case stress-ng application): 

* netp - the percentage of physical network
* nets - the percentage of network queue interference.
* blk - the percentage of disk interference.
* mbw - the percentage of memory bus interference.
* llcmr - the percentage of cache miss.
* llocc - the percentage of cache interference.
* cpu - the percentage of cpu interference.

## Saving the Results

The above results were captured at some point while the application was running. If you are interested in obtaining the history of the outputs given by IntP during the life cycle of the application, the following command can be used:

```shell
watch -n1 -d 'tail /proc/systemtap/stap_*/intestbench -n 1 >> output.txt'
```

The file created by the previous command called **output.txt** contains the results generated by intP every second.
